
# -- 生成 fbx 的主流程:
    用 unity mesh 生成 mesh 实例                  -- done
    用它创建 gameobj                              -- done
    将这个 gameobj 存储为一个 prefab (可选)        -- done
    用 fbx explorer 将这个 gameobj 存储为一个 fbx  -- done


# ---------------------------------
#  更高效地生成 mesh:
    制作一些工具:
    

# 生成 四边形:
    提供: 面上的点,  面法线,  4个顶点 (或两轴,两轴半径) 此函数可以自动生成所需的 4个顶点, 两个三角形 等数据




# ---------------------------------
#  用边框来切割柜子, 
首先不关系空间划分算法, 在最简方案里, 就是用刀来切割柜子, 每一刀都一分为二;
每画一刀, 都生成一条边, 实际上就是分成了两个更小的空间;

前期使用 fake 方法, 手动切割几刀来模拟;

这些刀需按次序排列, 从大到小;
每一次, 都是在一个空间里, 分配一个 矩形;

按照这个分法, 所有空洞都是 长方体, 都可以统一设置;


# 假设 柜子 左下角(前角) 为 0点


# 尝试, 让 二叉树 分割 和 cell/partition 的生成 同步进行:
首先提供一个 根 cell, 然后每次根据一个 物体, 分配一个 子cell 给它,
这个 子cell 的尺寸一定小于 cell, 可以随机把它放在一个角落上 (4个角落) 
一定为它分配一个 aabb 空间, 所有要先后切两刀, 先横先竖随意;
---
切了两刀后, 原本的 rootcell 被建了两层, 获得了 4个新 cell, 其中一个 cell 被填满; 一个 cell 是非叶节点, 两个 cell 是叶节点;

可以将 空的 叶节点从小到大 存储, 这样能节省空间;


# 每个 partition, 根据自己的 parent, 和 t 值, 可以计算出自己的 杆子两端pos, 顺带计算出自己的 4个顶点;
partion 的4个顶点 次序是固定的, 



# Partition 的三角形分配:
当一根长的 Partition 中间连上一根短的 Partition 后, 长 partition 的顶点会变多, 它的 三角形分布会变复杂;

但是有规律:
    一定在长边上出现新的点, 一次出现两个点;
    ---

# 几何建模 - Geometric Modeling


    可以自己实现一版拙劣版的;
    两侧多出来的顶点一定是 偶数个;

    +0 -> 1
    +2 -> 3
    +4 -> 5
    +6 -> 7
    ---
    不管上述多出来的顶点加在哪一边, 最终需要添加的内边数量都是恒定的;

#  可以实现一版最简单的;
   从上往下, 让顶点在拓扑概念上两两对齐, 这样, 前面就构成了很多个 四边形,  这些四边形, 按常规拆成若干对 三角形, 
   最后有一边特别长, 那些多出来的顶点, 统统和短边最后一个顶点 连成三角形;
    ---
    看起来很容易实现;


#  顶点的全局化:
    在把柜子 mesh 化的过程中, partition 和 cell 会共用顶点, 每个顶点都要用 hashmap 来管理, 分配 vertexidx 给它;
    
    
# 每个 cell 记录自己 4 个方向的 partition;
    这样可以把 新加的

# 截去不用的 partition 段:
    浸润机制:
    每个 partion 维护 [0,1] 区间, 如果在它某一侧填入物体, 这一段就被浸润;
    最后, 没有浸润的段, 不画;

# 每个 cell 维护自己 四个方向的 partition, 当这个 cell 被填入, 四个方向的 partition 都要写入值;

    一个独立算法, 提供一个点, 这个点投影到 线段上, 得到对应的 t 值;


# 被删除的 partition 的那段, 要特别处理, 来实现它的 立体化

# partition 的每条边, 都会被拓展为一个面, 记录所有的边, 最后统一生成这些面;



# 如何把 连接点 塞到 partition 中, 可以做得更精细点;
    一种办法是: 
    塞的时候随便塞,  最后集中排序;
    基于 夹角,  这个方法很好;

    Vector3.SignedAngle


# 顶点绕 partition 一圈, 这些顶点排好序后, 可以得到一圈边,
每个边 都可以去三角形信息里搜索, 看看自己是否被两个三角形公用
如果没公用,  这个边就要向后延申出一个面;


# 顶点新管理:
当一个 顶点出现两种 法线时,  就需要独立出一个来;


# 疏忽:
    vertex 需要存两份,  一份是基于 总体 hash 的, 这样避免 不同法线的 vertex 被合并
    另一份是基于 poshash 的,  这样相同 poshash 的 vertex, 会被看作是同一个;


    
# uv1 异常
可能是和 另一个法线的 顶点 的 uv 值 串了....







